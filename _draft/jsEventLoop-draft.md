---
layout: post
title: "[JS] 자바스크립트 동작 원리와 이벤트루프"
date: 2019-10-26 12:00:00
category:
- javascript
tag:
- javascript
comments: true
---

자바스크립트는 '단일 스레드'기반의 언어다. 이말은 동시에 하나의 작업만을 처리할 수 있다는 말이다.  
하지만 실제로 자바스크립트를 사용하는 환경을 보면 동시성(Concurrency)을 가지고 있고 성능 또한 우수하다.  
예를 들어 월마트가 노드JS 서버로 블랙프라이데이 온라인 트래픽의 53%를 처리할 때 노드 서버의 CPU 이용도가 약 1%였다는 것, 페이팔이 자바에서 노드JS로 교체 후 평균 응답시간이 35%가 단축된 것과 같은 사례들이 우수한 성능을 보여주고 있다는 증거다.
어떻게 단일 스레드 기반의 언어가 이런 성능을 낼 수 있었는 지 정리해보았다.

## 정리하게 된 동기
대용량 트래픽을 처리하기 위해 큰 기업들이 어떻게 이를 해결했는지 사례들을 찾아보고 있었다. 근데 눈에 띄는 사례 중 페이팔이 자바에서 노드JS로 교체 후 평균 응답시간이 35%나 단축되었다는 것을 알게 되었다. 평소 자바스크립트를 좋아하는 필자에게는 재밌는 사례였다.

하지만 의문점이 있었다. 아무리 이벤트 루프 기반의 비동기성을 지원한다고 해도, 많은 동시성이 요구될 수 많은 요청에 대해 어떻게 싱글 스레드인 자바 스크립트가 우수한 성능을 낼 수 있는지 궁굼했다.

그래서 큰 그림으로만 이해하고 있던 자바스크립트의 동작 원리에 대해 많은 자료를 찾아보게 되었고, 동작 원리와 내가 간과하고 있던 점을 정리하게 되었다.


## 자바스크립트 런타임(Runtime)
자바스크립트 엔진은 메모리 힙(Heap)과 단일 호출 스택(Call Stack)을 가지고 있다. 그리고 이 자바스크립트 엔진을 구동하는 환경(Node.js, 브라우저)이 큐(Queue)와 이벤트 루프(Event Loop)를 통해 비동기와 동시성을 담당한다.

엔진과 구동 환경을 언급한 것으로 예측할 수 있지만 ECMAScript 자체에는 단일 호출 스택, 큐, 이벤트 루프 등에 대한 명세는 없다. 중요한 것은 자바스크립트 엔진이 단일 호출 스택을 이용해서 실행하고, 엔진이 실행되는 환경 즉, 브라우저와 노드JS와 같은 곳에서 큐와 이벤트 루프를 통해 비동기성과 동시성을 처리하는 것이다.

### 힙(Heap)
객체들이 힙 안에 할당된다. 힙은 구조화되지 않은 넓은 메모리 영역을 지칭한다.

### 단일 호출 스택(Call Stack)
자바스크립트 엔진은 단일 호출 스택(Call Stack)을 가지고 있다. 하나의 호출 스택만을 가지고 있기 때문에 한번에 단 하나의 함수만 처리할 수 있다.  
이렇게 하나의 함수가 처리될 때 다른 함수가 끼어들 수 없는 것을 *Run to completion*이라고 한다.

### 큐(Queue)
이벤트 큐, 태스크 큐라고도 불리는 자바스크립트에서 큐는 자바스크립트 엔진 자체에 존재하지 않는다. 큐는 자바스크립트 엔진을 실행하는 환경에서 존재한다.  
큐의 역할은 호출 스택이 비워지기 전까지 실행될 콜백 함수들을 대기시키는 역할을 한다.

### 이벤트 루프(Event Loop)
이벤트 루프 또한 자바스크립트 엔진을 실행하는 환경에서 존재한다. 이벤트 루프는 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 한다. 이때 콜백 함수는 호출 스택에 추가된다.

### 자바스크립트의 동작
1. 자바스크립트에서 함수가 호출될 때 단일 호출 스택에 쌓인다.
2. 이때 Web Api에서 사용되는 비동기 함수(대표적으로 setTimeout을 예로 들수 있다)들은 실행되고 콜백함수를 태스크 큐에 쌓는다.
3. 이벤트 루프는 호출 스택이 비워질 때 큐에 있던 태스크를 호출 스택으로 옮긴다.
4. 이벤트 루프는 큐가 비워졌으니 다시 생길때까지 기다린다.

간단한 코드로 이 실행순서를 시각화할 수 있다.

```js
function foo() { 
  console.log('foo()');
}

function bar() {
  console.log('bar()');
}

setTimeout(foo, 10);
bar();

/**
bar()
foo()
*/
```

위 코드를 동기적으로 동작할 것이라고 예상하고 본다면 10ms 뒤에 foo()가 출력되고, 그 다음 bar()가 출력될 것이라 예상할 것이다. 하지만 setTimeout은 Web API에서 제공되는 비동기 함수임으로 콜백함수를 큐에 쌓기 때문에 스택에 존재하는 foo() 함수가 실행되어 비워질 때까지 대기하게 된다.

이 코드의 호출 스택 순서를 시각화하면 아래와 같다. (anonymous는 익명함수이다. 전역 환경에서 실행되는 코드는 한 단위의 코드블록으로써 가상의 익명함수로 감싸져 있다. 그래서 실행될 떄 맨 아래 추가되고 마지막 함수가 종료될 때 제거된다.)

![CallStack](/assets/images/post/stackExample.png)*\<호출 스택 변화 순서\>*



## 자바스크립트가 단일 스레드라는 것
위에서 알 수 있듯이 단일 호출 스택을 사용하는 자바스크립트 환경 특성상 동시에 하나의 요청만 처리할 수 있다. 근데 어떻게 노드JS에서 높은 동시성을 요구할 때 높은 성능을 낼 수 있었을까?

필자는 해당 글을 정리하기 이전에는 비동기 I/O에 대한 처리 또한 단일 스레드라고 생각했다. 하지만 ECMAScript, 자바스크립트 엔진, 엔진 구동 환경을 분리해서 이해하고 접근했더니 더 깊게 알 수 있었다.

![NodeJSSystem](/assets/images/post/nodejsSystem.jpg)*\<노드JS 시스템 다이어그램\>*

위 이미지를 보면 노드JS는 비동기 I/O를 지원하기 위해 [libuv](https://libuv.org/) 라이브러리를 사용하며, libuv는 여러개의 워커 스레드를 가지고 있는 것을 확인할 수 있다.

위 내용을 기반으로 자바스크립트가 단일 스레드라는 표현은 자바스크립트 엔진의 단일 호출 스택 환경에만 적용이 된다는 것을 알 수 있다. 그리고 비동기 I/O들을 여러개의 스레드를 사용해서 처리한 다는 것을 알 수 있다.

그리고 **이벤트 루프**의 역할은 단지 태스크 큐를 관리하는 게 아닌, 실제 단일 호출 스택을 사용하는 자바 스크립트 엔진과 여러개의 스레드를 사용하고 있는 자바스크립트 구동 환경이 상호 연동하는 중요한 역할을 하고 있는 것이다.


## 글을 마무리 하며
자바스크립트의 동작 원리를 로우 레벨로 조사하기 이전에는 비동기I/O로 실행되는 메커니즘 자체가 높은 성능을 낼 수 있는 이유라고 생각했다. '단일 스레드 기반의 언어'라는 의구심을 시작으로 조사해보면서 어떻게 많은 동시성을 가진 I/O 업무를 처리할 수 있었는 지 명확하게 알 수 있었다.

역시 내가 이해하고 있는 것에 대한 의심을 멈추면 안되겠다. 지식의 깊이는 무한하다는 것을 잊지 말고, 끊임 없이 내 지식의 타당성을 찾으려고 하는 자세를 다시 한번 마음에 새긴다.

그리고 다시 한번 자바스크립트는 다른 언어와 다른 부분이 많고 로우레벨로 갈 수록 학습곡선의 경사가 다른 언어들과 비교적 높다는 생각이 든다. 그래서 더 매력적인 언어로 느껴지고 코드 작성시 즐거움이 배로 되는 것 같다.

자바스크립트로 프로그래밍하는 것을 좋아하는데, 이녀석을 알면 알 수록 더 좋아지는 것 같다. 재밌는 녀석이다.  
평소 프로토타입 작성용으로 노드JS를 사용했는데, 많은 CPU 리소스를 요구하지 않는 웹 프로젝트는 노드JS를 사용해봐야겠다.

